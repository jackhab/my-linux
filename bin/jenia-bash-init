#!/bin/bash

alias rm='rm -i'

alias ll='ls -lh  --group-directories-first --time-style="+%d/%m/%y %H:%M:%S"'
alias la='ll -a'

alias yum='sudo yum -y'
alias wireshark='sudo wireshark'
alias virsh='sudo virsh'

alias o='xdg-open'


export PATH=${PATH}:~/my/bin


#fixes "Couldn't connect to accessibility bus" warning when using SSH
export NO_AT_BRIDGE=1


#show file's full path
full() {
    echo "${PWD}/$1"
}


typel() {
    if [[ $(type -t $1) == "file" ]] ; then
        readlink -f $(type -p $1)
    else
        type $1
    fi
}


f() {
    [[ -z $1 ]] && { echo "Find file in current directory. Usage: f FILE_NAME [DIR]" ; return 1 ; }

    find $2 -iname *${1}*
}

d() {
    [[ -z $1 ]] && { echo "Compare two files. Usage: d FILE_NAME1 [FILE_NAME2]" ; return 1 ; }

    #disable less pager in git
    PAGER=""

    #if no second file use first file name as a pattern and comapre first two matching files
    if [[ -n $2 ]] ; then
        git diff --color-words "$1" "$2" |  tail -n +5
    else
        #show actual file names to be compared
        tput bold ; find . -maxdepth 1 -type f -name "$1*" | head -n 2 | xargs ; tput sgr0

        find . -maxdepth 1 -type f -name "$1*" | head -n 2 | xargs git diff --color-words |  tail -n +5
    fi

    # echo PAGER="" git diff --color-words "$Files"
}


g() {
    [[ -z $1 ]] && { echo "Find text in files. Usage: g REGEX_PATTERN [FILE]" ; return 1 ; }

    #using C locale to avoid "invalid UTF-8 byte sequence in input" bug with binary files

    #if no terminal g() is used as a pipe: search in stdin
    if [[ ! -t 0 ]] ; then
        while read Line ; do
            echo "$Line"
        done  |  LC_ALL=C grep -P --color -I "$@"

        exit
    fi

    declare -a Params=("$@")

    #if last param is not an existing file search in all files
    [[ -e ${Params[@]: -1} ]] || Params+=(*)

    LC_ALL=C grep -P --exclude-dir='*svn*' --color -n -I -r "${Params[@]}"
}


snr() {
    [[ -z $1 || -z $2 ]] && { echo "Replace text in files. Usage: snr SEARCH_TEXT REPLACE_TEXT [FILE]" ; return 1 ; }

    BakDir="/tmp/sed-bak"
    mkdir -p $BakDir

    #if file name given use it, else replace in all files recursively
    if [[ -n $3 ]] ; then
        Files="$3"
    else
        Files="*"
    fi

    #escape slashes in the strings
    From=${1////\\/}
    To=${2////\\/}

    #grep is very fast in pattern matching: use it to select files to process
    grep --exclude-dir='*svn*' -r --binary-files=without-match --files-with-matches -P -e "$1" $Files | \
	    while read -r File ; do
	        #backup in a separate directory
	        \cp -f "$File" $BakDir

            perl -p -i -e "s/$From/$To/g" "$File"

            #show replacement results: use git diff if possible, select only colored lines
            if type git &>/dev/null ; then
                git diff --no-index --color-words --word-diff-regex='.' "$BakDir/$(basename $File)" "$File" |  tail -n +5 | \grep -P "\[3[12]m"
            else
                diff -u "$BakDir/$(basename $File)" "$File" | \grep -P "(^|\dm)[-+][^-+]" ; echo
            fi
	    done

    #display replacement results
    # grep -r --color=always -e "$To" /tmp/sed-out/* 2>/dev/null | sed 's!/tmp/sed-out/!!'
}


ssh-mount() {
	[[ -z $1 ]] && return 1

    NoCol=${1//:/}           #remove :
    NoSlash=${NoCol////-}    #replace / with -
    MountDir=${NoSlash/%-/}  #remove last -

    #clean up empty dirs from previous mounts
    find ~/mnt -maxdepth 1 -type d -empty -exec rmdir {} \;

	mkdir -p ~/mnt/$MountDir || return 1

    sshfs $1 ~/mnt/$MountDir || return 1

    echo $1 mounted on ~/mnt/$MountDir
}


#SshCon array has: CLIENT_IP, CLIENT_PORT, SERVER_IP, SERVER_PORT
SshCon=($SSH_CONNECTION)
#take SERVER_IP and add a colon if it's present
SshIp=${SshCon[2]}${SshCon[2]:+ }

#show SSH prompt in different color
[[ -n $SSH_CONNECTION ]] && Color=34 || Color=35


[[ -n $MC_SID ]] && Mc='[mc] ' || Mc=''


#if git is installed show git status in prompt
if . /usr/share/git-core/contrib/completion/git-prompt.sh 2>/dev/null ; then
    #show unstaged (*) and staged (+) changes
    export GIT_PS1_SHOWDIRTYSTATE="+"
    #show stashed ($) changes
    export GIT_PS1_SHOWSTASHSTATE="+"
    #show untracked (%) changes
    export GIT_PS1_SHOWUNTRACKEDFILES="+"
    #show branch status relative to its upstream
    export GIT_PS1_SHOWUPSTREAM="verbose"

    #prompt with pwd, host SSH IP, git status, user name, hostname
    PS1='\n\[\033[01;${Color}m\]$Mc$SshIp$(pwd)$(__git_ps1)\n\u@\h$\[\033[00m\] '
else
    PS1='\n\[\033[01;${Color}m\]$Mc$SshIp$(pwd)\n\u@\h$\[\033[00m\] '
fi


#normally these settings go into ~/.inputrc without the bind command
if tty -s ; then
    bind 'set show-all-if-ambiguous on'
    bind 'set completion-ignore-case on'
    bind 'set completion-prefix-display-length 1'
    bind 'set history-size 1000'
    bind 'set visible-stats on'
fi


CheckAlive() {
    timeout 0.1 ping -c 1 $1 &>/dev/null
}


command_not_found_handle() {
    if [[ $# == 1 ]] ; then
        if [[ $1 =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || timeout 0.1 ping -c 1 $1 &>/dev/null ; then
            #full IP given
            Host=$1
        elif [[ $1 =~ ^[0-9]{1,3}$ ]] && (( $1 <= 255 )) ; then
            Host=10.1.0.$1
        fi

        if [[ -n $Host ]] ; then
            echo -n `tput sc`"ssh $Host"`tput rc`
            ssh $Host
            return
        fi
    fi

    echo "'$1' command not found"
}


